

local function draw_line(from, to, color)
	msg.post("@render:", "draw_line", { start_point = from, end_point = to, color = color })
end

function init(self)
  self.wheel_base = 100
  self.steering_angle = 15
  self.engine_power = 2400
  self.friction = -0.8
  self.drag = -0.001
  self.braking = -450
  self.max_speed_reverse = 350
  self.slip_speed = 350
  self.traction_fast = 0.04
  self.traction_slow = 0.7

  self.acceleration = vmath.vector3()
  self.velocity = vmath.vector3()
  self.steer_direction = 0

  self.input = vmath.vector3()
  self.tiremarks_playing = false

  -- kinematic collicion correction
  self.correction = vmath.vector3()

  msg.post(".", "acquire_input_focus")

end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
end

function fixed_update(self, dt)
  self.steer_direction = -self.input.x * math.rad(self.steering_angle)
  self.acceleration = vmath.vector3()
  -- self.velocity = vmath.vector3()

  local pos = go.get_position()
  local facing = vmath.rotate(go.get_rotation(), vmath.vector3(1, 0, 0))

  -- accelaration
  -- self.velocity = self.input.y * facing * 500
  if self.input.y > 0 then
    self.acceleration = facing * self.engine_power
  elseif self.input.y < 0 then
    self.acceleration = facing * self.braking
  end

  -- friction
  if vmath.length(self.velocity) < 5 then
    self.velocity = vmath.vector3()
  end

  local friction_force = self.velocity * self.friction
  local drag_force = self.velocity * vmath.length(self.velocity) * self.drag
  self.acceleration = self.acceleration + drag_force + friction_force

  -- calculate_steering
  local rear_wheel = pos - facing * self.wheel_base / 2.0
  rear_wheel = rear_wheel + self.velocity * dt

  local front_wheel = pos + facing * self.wheel_base / 2.0
  local wheel_rot = vmath.quat_rotation_z(self.steer_direction)
  local front_wheel_vel = vmath.rotate(wheel_rot, self.velocity);
  front_wheel = front_wheel + front_wheel_vel * dt

  local new_heading = vmath.normalize(front_wheel - rear_wheel)
  traction = self.traction_slow
  if vmath.length(self.velocity) > self.slip_speed then
    traction = self.traction_fast
  end
  
  local cmp = new_heading
  if vmath.length_sqr(self.velocity) > 0 then cmp = vmath.normalize(self.velocity) end
  local dot = vmath.dot(new_heading, cmp)
  if dot >= 0 then
    -- self.velocity = new_heading * vmath.length(self.velocity)
    self.velocity = vmath.lerp(traction, self.velocity, new_heading * vmath.length(self.velocity))
  elseif dot < 0 then
    self.velocity = -1 * new_heading * math.min(vmath.length(self.velocity), self.max_speed_reverse)
  end

  if dot < 0.95 and traction == self.traction_fast and self.tiremarks_playing == false then
    particlefx.play('under_car#tiremarks')
    self.tiremarks_playing = true
  end

  if (dot >= 0.95 or traction == self.traction_slow) and self.tiremarks_playing == true then
    particlefx.stop('under_car#tiremarks')
    self.tiremarks_playing = false
  end

  local new_rot = vmath.quat_from_to(vmath.vector3(1, 0, 0), new_heading)
  go.set_rotation(new_rot)

  self.velocity = self.velocity + self.acceleration * dt
  go.set_position(pos + self.velocity * dt)

  -- draw_line(pos, (pos + facing * 500), vmath.vector4(1,0,0,1))
  -- draw_line(pos, (pos + new_heading * 500), vmath.vector4(0,1,0,1))
  -- draw_line(rear_wheel, front_wheel, vmath.vector4(0, 0, 1, 1))
  -- draw_line(front_wheel, front_wheel + vmath.rotate(wheel_rot, facing) * 50, vmath.vector4(0, 0, 1, 1))
  -- draw_line(front_wheel, front_wheel + vmath.rotate(wheel_rot, front_wheel_vel) * 50, vmath.vector4(0, 1, 1, 1))
  if vmath.length_sqr(self.correction) > 0 then
    -- self.velocity = vmath.project(self.velocity, self.correction) * vmath.length(self.velocity)
    -- print(self.velocity)
    if self.correction.x ~= 0 then self.velocity.x = 0 end
    if self.correction.y ~= 0 then self.velocity.y = 0 end
    -- self.velocity = vmath.vector3()
  end

  local from = go.get_position()
	local to = from + new_heading * 1000
	local result = physics.raycast(from, to, { hash("default") }) -- <4>
	if result then
		draw_line(from, result.position, vmath.vector4(1, 0, 0, 1)) -- <5>
	else
		draw_line(from, to, vmath.vector4(1, 0, 0, 1)) -- <6>
	end

  self.correction = vmath.vector3()
end


function on_message(self, message_id, message, sender)
  -- Handle collision
  if message_id == hash("contact_point_response") then
    -- Get the info needed to move out of collision. We might
    -- get several contact points back and have to calculate
    -- how to move out of all of them by accumulating a
    -- correction vector for this frame:
    if message.distance > 0 then
      -- First, project the accumulated correction onto
      -- the penetration vector
      local proj = vmath.project(self.correction, message.normal * message.distance)
      if proj < 1 then
        -- Only care for projections that does not overshoot.
        local comp = (message.distance - message.distance * proj) * message.normal
        -- Apply compensation
        go.set_position(go.get_position() + comp)
        -- Accumulate correction done
        self.correction = self.correction + comp
      end
    end
  end
end

function on_input(self, action_id, action)
  if action_id == hash("right") then
    if action.released then
      self.input.x = self.input.x - 1
    else
      self.input.x = self.input.x + 1
    end
  end

  if action_id == hash("left") then
    if action.released then
      self.input.x = self.input.x + 1
    else
      self.input.x = self.input.x - 1
    end
  end

  if action_id == hash("accelerate") then
    if action.released then
      self.input.y = self.input.y - 1
    else
      self.input.y = self.input.y + 1
    end
  end

  if action_id == hash("break") then
    if action.released then
      self.input.y = self.input.y + 1
    else
      self.input.y = self.input.y - 1
    end
  end

  self.input.x = math.max(-1, self.input.x)
  self.input.x = math.min(1, self.input.x)
  self.input.y = math.max(-1, self.input.y)
  self.input.y = math.min(1, self.input.y)


  if action_id == hash('touch') and action.pressed then
    go.set_position(vmath.vector3())
  end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
